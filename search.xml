<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[强化学习（一）]]></title>
    <url>%2F2018%2F10%2F31%2FReinforce_Learning%2F</url>
    <content type="text"><![CDATA[我看到网上的强化学习教程通常比较复杂, 看完莫烦python后总结出来如下, 我将主要用代码形式进行理论的展现, 其中个别地方用的是OPENAI的表示方式 一、回合更新(Monte-Carlo update)玩完所有的步数, 等到一个episode结束之后再更新数值 Monte-Carlo Learning这个方法比较esay, 就是根据尽可能多的经验, 以及平均期望来更新数值。实验成本大, 并且现在很多需要决策的问题是没有结束标志的。 二、单步更新(Temporal-Difference update)每走一步都会更新当前的数值 Q-Learning(off-policy), Sarsa(on-policy) 1. 什么是off/on-policy?off-policy的更新value时候的next_action不一定会真实采取, 而on-policy更新时候的next_value就是真实采取的 小明正在准备高考, 课间的时候小明在思考接下来学习什么知识。首先, 小明想学习数学, 但是小明的数学已经学习的很熟练了，于是小明并没有拿出课本, 而是在脑海里把课本背诵了一边, 这样一来, 小明虽然没有拿出课本, 但是依然更新了当前的知识, 接下来小明可能拿出的是英语/语文/物理课本进行学习。这就是我们的off-policy。倘若是on-policy, 小明就失去了默背这一流程, 想回忆一下数学下一步骤必须拿出数学课本 2. epsilon_greedy策略 取到最大值的概率为 (1-eps) + (eps)/n取到其他n-1种动作的概率为 (eps)/n 12345678910111213141516def epsilon_greedy(Q, state, nA, eps): """Selects epsilon-greedy action for supplied state. Params ====== Q (dictionary): action-value function state (int): current state nA (int): number actions in the environment eps (float): epsilon """ if random.random() &gt; eps: # 此时是选取最大数值的action进行返回 return np.argmax(Q[state]) else: # 这个时候对每个取平均 return random.choice(np.arange(env.action_space.n)) 3. Q-learning with sarsa_max?(off-policy)sarsa_max: 选取下一状态是value最大的动作更新当前状态 1234567891011# Q-learning Sarsamaxdef update_Q_sarsamax(alpha, gamma, Q, state, action, reward, next_state=None): # Returns updated Q-value for the most recent experience. current = Q[state][action] # estimate in Q-table (for current state, action pair) Qsa_next = np.max(Q[next_state]) if next_state is not None else 0 # find the max q in next_state, but this action is not the real action target = reward + (gamma * Qsa_next) # construct TD target new_value = current + (alpha * (target - current)) # get updated value return new_value 1234567891011121314# Q-learning while True: action = epsilon_greedy(Q, state, nA, eps) # epsilon-greedy action selection, get next_action in every interation next_state, reward, done, info = env.step(action) # take action A, observe R, S' score += reward # add reward to agent's score Q[state][action] = update_Q_sarsamax(alpha, gamma, Q, \ state, action, reward, next_state) state = next_state #只更新状态 if done: tmp_scores.append(score) # append score break 4. Sarsa Learning每次迭代都会选出下一状态和下一状态将要采取的动作，根据事实(update_Q_sarsa)来进行更新12345678910def update_Q_sarsa(alpha, gamma, Q, state, action, reward, next_state=None, next_action=None): #Returns updated Q-value for the most recent experience. current = Q[state][action] # estimate in Q-table (for current state, action pair) # get value of state, action pair at next time step Qsa_next = Q[next_state][next_action] if next_state is not None else 0 target = reward + (gamma * Qsa_next) # construct TD target new_value = current + (alpha * (target - current)) # get updated value return new_value 123456789101112131415161718while True: next_state, reward, done, info = env.step(action) # take action A, observe R, S' score += reward # add reward to agent's score if not done: next_action = epsilon_greedy(Q, next_state, nA, eps) # epsilon-greedy action Q[state][action] = update_Q_sarsa(alpha, gamma, Q, \ state, action, reward, next_state, next_action) state = next_state # S &lt;- S' action = next_action # A &lt;- A' ''' 这里会根据传入update函数的next_action 和 next_state进行更新 ''' if done: Q[state][action] = update_Q_sarsa(alpha, gamma, Q, \ state, action, reward) tmp_scores.append(score) # append score break 5. expected Sarsa3,4 种描述的更新方法都是取单一action的value, 在期望Sarsa中将对所有的action产生的value计算一个平均期望进行更新 1234567891011def update_Q_expsarsa(alpha, gamma, nA, eps, Q, state, action, reward, next_state=None): """Returns updated Q-value for the most recent experience.""" current = Q[state][action] # estimate in Q-table (for current state, action pair) policy_s = np.ones(nA) * eps / nA # 建立一个向量储存概率，每一个都是 （eps / nA）, nA表示action数量 policy_s[np.argmax(Q[next_state])] = 1 - eps + (eps / nA) # 将最大value的action的概率变为1 - eps + (eps / nA) Qsa_next = np.dot(Q[next_state], policy_s) # get value of state at next time step target = reward + (gamma * Qsa_next) # construct target new_value = current + (alpha * (target - current)) # get updated value return new_value]]></content>
      <categories>
        <category>Reinforcement Learning</category>
      </categories>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ basic rules]]></title>
    <url>%2F2018%2F10%2F30%2Fc%2B%2B_rules%2F</url>
    <content type="text"><![CDATA[C++ STL1. mapThis can be use there are some simple rules, for example, an integer refers to a string, like in leetcode12 and leetcode1312345678910111213141516//#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; int main()&#123; map&lt;int, string&gt; mymap; mymap.insert(pair&lt;int, string&gt;(3,"sdf"));//using "insert" to do the insert operation map&lt;int, string&gt;::iterator iter;// define an interator for (iter = mymap.begin(); iter != mymap.end(); iter ++)&#123;// from begin() to the end() cout&lt;&lt;iter-&gt;first&lt;&lt;" "&lt;&lt;iter-&gt;second;// first and second value &#125; return 0;&#125; c++ String12int first = str.find(s); // return the first index of substring "s" in "str"int last = str.find(s); // return the last index of substring "s" in "str"]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>data_structure</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursion---leetcode]]></title>
    <url>%2F2018%2F10%2F30%2FRecursion%2F</url>
    <content type="text"><![CDATA[RecursionFrom my perspective, Recursion is an efficient way because it makes us to only look at the current step. However, its complexity is very high. Example1. 10. Regular Expression Matching from Leetcode You can see the description on the above link. My problem is that it contains tooooo many different combination of “character”, “.” and “*“. It looks like a time array, which you should look at the moment. time before and the future, which is very bothering. So what we do here is only determine the current action, and let the function to judge what to do next itself. So, given two arries, we have several choices whether reach the end?12345678910# p and s reach the end at the same time# p reach the end, but s doesn'tdef isMatch(s, p)&#123; if(p.empty())&#123; if(s == empty()) return 1; else return 0 &#125;&#125;``` 2. if the first character match? def isMatch(s, p){ bool first_match; if(s[0] == p[0] || p[0] == ‘.’) first_match = true; }13. is it followed by * ? def isMatch(s, p){ if(p.length() &gt;= 2 || p[1] == ‘‘): # the second character of p is # this if means: * is 0 or not return isMatch(s, p.substr(2)) || (first_match &amp;&amp; isMatch(s.substr(1), p) else: return first_match &amp;&amp; isMatch(s.substr(1), p.substr(1)) }1The complete code in C++ #include using namespace std;class Solution {public: bool isMatch(string s, string p) { bool first = false; if(p.empty()){ return (s.empty()); } else{ first = (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == ‘.’)); } if(p.length()&gt;= 2 &amp;&amp; p[1] == ‘‘){ return (isMatch(s, p.substr(2)) || (first &amp;&amp; isMatch(s.substr(1), p) ) ); // make be 0 || make * be at least 1 } else return first &amp;&amp; isMatch(s.substr(1), p.substr(1)); }};int main() { Solution solution; return 0; }`We can see that the compexity is high. Because there are many duplicated calculations. SO we can set an array to solve this problem, this is same with DYNAMIC PROGRAMMING, which we will dicuss in there.]]></content>
      <categories>
        <category>leetcodeNotes</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming---Leetcode]]></title>
    <url>%2F2018%2F10%2F30%2FDP%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingThe situations are that our current situations depend on the old calculations. So we don’t need to start from the begining again, we can store the outcome of each step so we can cite it directly. Usually, the parameters of the function are the index instead of the object (string etc.) itself. Because our operations are on the matrix. Example1. 5. Longest Palindromic Substring from LeetcodeWe calculation according to the length of the string. If we wanna judge ‘cbbaac’, we can find whether ‘bbaa’ is Palindromic, then find the character from the two ends are same. Example2. 10. Regular Expression Matching from the LeetcodeJust like we talk in “Recursion”, DP algorithm sometimes help Recursion to decrease the calculation. Such as: 12345def dp(i, j, arr): if arr[i][j] != null: ## it can returns directly return arr[i][j] else: calculate the arr[i][j]]]></content>
      <categories>
        <category>leetcodeNotes</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to apply hexo to Github Page (一)]]></title>
    <url>%2F2018%2F10%2F20%2Fhexo%2F</url>
    <content type="text"><![CDATA[How to build up your hexo on Github PageFirstly, you need to sign up a github account and build a repo which has the same name with your github. github name : JasonWang0808gitpage name : JasonWang0808.github.io Secondly, prepare the hexo The set up steps are as followed:Step1. Install Node.js and Git and make sure they have been installed properly. 1234Win+R cmdnode -vgit -version step2. Prepare the SSH key and goto the github “SSH and GPG keys” to fill in 123456#open the git bashssh-keygen -t rsa# type enter three timescd C:\Users\Administrator\.sshcat id_rsa.pub# copy the content 123#evaluatessh -T git@github.com## return Hi step3. Install hexo 123456789cd xxxnpm install hexo-cli -ghexo init Hexo cd /Hexo npm instal hexo cleanhexo generate（可简写为hexo g） hexo sever（可简写为hexo s）npm install –save hexo-deployer-git step4. Modify the config 12345# use sublime to open /blog/_config.yml and find "deploy"deploy:type: gitrepo: git@github.com:yourname/yourname.github.io.gitbranch: master step5. modify ./config.yml and ./themes/next/config.yml depends on your hobby 1hexo d Step6. next, you can change your theme and add more decorations to your website A good way to learn to decorationstep5. modify ./config.yml and ./themes/next/config.yml depends on your hobby 1hexo d Step7. start to write on your github page with hexo 1234hexo new "xxx"# this can help you to build a new xx.mdhexo new page "xxx"# this help you to build a new page, for example, "categories" Every xx.md has its head, for example, Title is the name. Tags are tags, you know. categories is a big package containing all the essays with this category12345---title: Notes of LeetCode(一)tags: [leetcode, c++,algorithm]categories: leetcodeNotes--- Finally, you can use Tengxun cloud to get a domain for your pageThere are two records you need to add12#get the ip address of your page ping www.xx.github.io]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notes of LeetCode (a)]]></title>
    <url>%2F2018%2F10%2F20%2Fleetcode%2F</url>
    <content type="text"><![CDATA[3. Longest Substring Without Repeating CharactersⅠ. DATA STRUCTURE: HashMap HashMap is a quick way to find elements in the time complexity of O(1) and is commonly used in leetcode. 1HashMap&lt;Charactor,Integer&gt; map = new HashMap&lt;&gt; (); Ⅱ. Method:Sliding WindowThe sliding window is an abstract concept commonly used in array/String problems. It likes Dynamic Programming, because we don’t know the answer until we finish it. The length is j - i because the arrange is [i, j) (left-closed, right-open). We set the ANS to record the longest answer. Once we find our next number is replucated in our map, we change the i to the number in our map, same with truncating. Then next, until we reach the end of the array. 1234567891011121314151617class Solution &#123; //map.put map.get map.containsKey public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0, j = 0, ans = 0; int l = s.length(); while(i &lt; l &amp;&amp; j &lt; l)&#123; if(map.containsKey(s.charAt(j)))&#123; //if next element in the map i = Math.max(map.get(s.charAt(j)) + 1, i); // abba, max is to prevent : "a" in the end makes i be '0' &#125; ans = Math.max(ans, j-i+1); // keep the bigger ans map.put(s.charAt(j), j); // refresh the map j ++; // goto next number &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcodeNotes</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2018%2F10%2F19%2FNew%20begining%2F</url>
    <content type="text"><![CDATA[Welcome to JunYu Wang’s siteI am proud that I’ve keep writing blogs for almost half year in 2018. The content are as followed. Notes of the CS system and data structure from the class Notes of the Deep-learning courses from Udacity …. The reason why today is very important is that I realize that my blogs shouldn’t have been regarded as merely “records of my study”. It should be more formal, more beautiful, more ordered, and most importantly, more inspiring.I always like new beginings and new challanges, which make me feel alive. So I want to delve furture into some specific areas of study to equip myself to be more professional. Notes of how to deal with the problems on Leetcode Notes of deeper details of algorithm such as object detection Notes of new classes in new school ….. CLICK “About” to see my RESUME CLICK “Categories” to see all the topics of my articles CLICK “Tags”… OOPS, this is under building CLICK “Search” to find the topic you have interests on Hope you Enjoy this 1234567891011if (you have any questions)&#123; case email: wangjunyu0808@gmail.com; case insgram: wangjunyu0808; case wechat: HeNeArKrXnTn default;&#125;I will be happy to share ideas with you]]></content>
  </entry>
</search>
