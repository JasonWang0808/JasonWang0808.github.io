<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junyu Wang&#39;s Blog</title>
  
  <subtitle>hello</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T04:52:21.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JunYu Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Data Structure</title>
    <link href="http://yoursite.com/2019/04/08/graph1/"/>
    <id>http://yoursite.com/2019/04/08/graph1/</id>
    <published>2019-04-09T04:51:19.146Z</published>
    <updated>2019-04-09T04:52:21.721Z</updated>
    
    <content type="html"><![CDATA[<h4 id="spanning-tree"><a href="#spanning-tree" class="headerlink" title="spanning tree"></a>spanning tree</h4><h5 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h5><p>time complexity: O(ElogV), using the priority_queue（Adjacency list）</p><p>time complexity: O(n^2), using the adjacent matrix</p><p>time complexity: O(E + Vlog(V)) (Best)</p><p>explanation: as you can see below, O(Vlog(V) + Elog(V)) = ElogV</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">while</span>(!q.empty())&#123; <span class="regexp">//</span> V</span><br><span class="line"><span class="number">2</span>.      u = extract_min(<span class="keyword">q</span>); <span class="regexp">//</span> <span class="keyword">log</span>(V)  </span><br><span class="line"><span class="number">3</span>.      <span class="keyword">for</span>(u: all the vertex)&#123;</span><br><span class="line"><span class="number">4</span>.          undate the u-&gt;<span class="keyword">x</span>; <span class="regexp">//</span> <span class="keyword">x</span> is other unvisted vertex</span><br><span class="line"><span class="number">5</span>.      &#125;</span><br><span class="line">      // <span class="number">3</span>-<span class="number">5</span> <span class="keyword">use</span> Edge <span class="keyword">times</span>(max), <span class="keyword">and</span> <span class="keyword">each</span> <span class="keyword">time</span> <span class="keyword">log</span>(V) to look up <span class="keyword">and</span> update</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spanning Tree (MST) algorithm. The program is </span></span><br><span class="line"><span class="comment">// for adjacency matrix representation of the graph </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt; </span></span></span><br><span class="line"><span class="comment">// Number of vertices in the graph </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 5 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to find the vertex with </span></span><br><span class="line"><span class="comment">// minimum key value, from the set of vertices </span></span><br><span class="line"><span class="comment">// not yet included in MST </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKey</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">bool</span> mstSet[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// Initialize min value </span></span><br><span class="line"><span class="keyword">int</span> min = INT_MAX, min_index; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) </span><br><span class="line"><span class="keyword">if</span> (mstSet[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt; min) </span><br><span class="line">min = key[v], min_index = v; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> min_index; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to print the </span></span><br><span class="line"><span class="comment">// constructed MST stored in parent[] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printMST</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> n, <span class="keyword">int</span> graph[V][V])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Edge \tWeight\n"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V; i++) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d - %d \t%d \n"</span>, parent[i], i, graph[i][parent[i]]); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to construct and print MST for </span></span><br><span class="line"><span class="comment">// a graph represented using adjacency </span></span><br><span class="line"><span class="comment">// matrix representation </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primMST</span><span class="params">(<span class="keyword">int</span> graph[V][V])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// Array to store constructed MST </span></span><br><span class="line"><span class="keyword">int</span> parent[V]; </span><br><span class="line"><span class="comment">// Key values used to pick minimum weight edge in cut </span></span><br><span class="line"><span class="keyword">int</span> key[V]; </span><br><span class="line"><span class="comment">// To represent set of vertices not yet included in MST </span></span><br><span class="line"><span class="keyword">bool</span> mstSet[V]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize all keys as INFINITE </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">key[i] = INT_MAX, mstSet[i] = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Always include first 1st vertex in MST. </span></span><br><span class="line"><span class="comment">// Make key 0 so that this vertex is picked as first vertex. </span></span><br><span class="line">key[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// First node is always root of MST </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The MST will have V vertices </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; V<span class="number">-1</span>; count++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// Pick the minimum key vertex from the </span></span><br><span class="line"><span class="comment">// set of vertices not yet included in MST </span></span><br><span class="line"><span class="keyword">int</span> u = minKey(key, mstSet); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the picked vertex to the MST Set </span></span><br><span class="line">mstSet[u] = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Update key value and parent index of </span></span><br><span class="line"><span class="comment">// the adjacent vertices of the picked vertex. </span></span><br><span class="line"><span class="comment">// Consider only those vertices which are not </span></span><br><span class="line"><span class="comment">// yet included in MST </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) </span><br><span class="line"></span><br><span class="line"><span class="comment">// graph[u][v] is non zero only for adjacent vertices of m </span></span><br><span class="line"><span class="comment">// mstSet[v] is false for vertices not yet included in MST </span></span><br><span class="line"><span class="comment">// Update the key only if graph[u][v] is smaller than key[v] </span></span><br><span class="line"><span class="keyword">if</span> (graph[u][v] &amp;&amp; mstSet[v] == <span class="literal">false</span> &amp;&amp; graph[u][v] &lt; key[v]) </span><br><span class="line">parent[v] = u, key[v] = graph[u][v]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// print the constructed MST </span></span><br><span class="line">printMST(parent, V, graph); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// driver program to test above function </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">/* Let us create the following graph </span></span><br><span class="line"><span class="comment">2 3 </span></span><br><span class="line"><span class="comment">(0)--(1)--(2) </span></span><br><span class="line"><span class="comment">| / \ | </span></span><br><span class="line"><span class="comment">6| 8/ \5 |7 </span></span><br><span class="line"><span class="comment">| / \ | </span></span><br><span class="line"><span class="comment">(3)-------(4) </span></span><br><span class="line"><span class="comment">9 */</span></span><br><span class="line"><span class="keyword">int</span> graph[V][V] = &#123;&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>&#125;, </span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>&#125;, </span><br><span class="line">&#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>&#125;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the solution </span></span><br><span class="line">primMST(graph); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h5><p>time complexity: O(ElogV), using union_set $/alpha(V)$</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sort(Edges); <span class="comment">// Elog(E)</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">find_union</span>(<span class="params">u</span>) !</span>= find_union(v)&#123;</span><br><span class="line">    make_union(u,v); <span class="comment">// Elog(V)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> edge pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, edge&gt;&gt; G; <span class="comment">// graph</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, edge&gt;&gt; T; <span class="comment">// mst</span></span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> V; <span class="comment">// number of vertices/nodes in graph</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graph(<span class="keyword">int</span> V);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddWeightedEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V) &#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//i 0 1 2 3 4 5</span></span><br><span class="line">    <span class="comment">//parent[i] 0 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line"> </span><br><span class="line">    G.clear();</span><br><span class="line">    T.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Graph::AddWeightedEdge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    G.push_back(make_pair(w, edge(u, v)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Graph::find_set(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// If i is the parent of itself</span></span><br><span class="line">    <span class="keyword">if</span> (i == parent[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// Else if i is not the parent of itself</span></span><br><span class="line">        <span class="comment">// Then i is not the representative of his set,</span></span><br><span class="line">        <span class="comment">// so we recursively call Find on its parent</span></span><br><span class="line">        <span class="keyword">return</span> find_set(parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Graph::union_set(<span class="keyword">int</span> u, <span class="keyword">int</span> v) &#123;</span><br><span class="line">    parent[u] = parent[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Graph::kruskal() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, uRep, vRep;</span><br><span class="line">    sort(G.begin(), G.end()); <span class="comment">// increasing weight</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.size(); i++) &#123;</span><br><span class="line">        uRep = find_set(G[i].second.first);</span><br><span class="line">        vRep = find_set(G[i].second.second);</span><br><span class="line">        <span class="keyword">if</span> (uRep != vRep) &#123;</span><br><span class="line">            T.push_back(G[i]); <span class="comment">// add to tree</span></span><br><span class="line">            union_set(uRep, vRep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Graph::print() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Edge :"</span> &lt;&lt; <span class="string">" Weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T[i].second.first &lt;&lt; <span class="string">" - "</span> &lt;&lt; T[i].second.second &lt;&lt; <span class="string">" : "</span></span><br><span class="line">                &lt;&lt; T[i].first;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.AddWeightedEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    g.AddWeightedEdge(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    g.kruskal();</span><br><span class="line">    g.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Find-shortest-path"><a href="#Find-shortest-path" class="headerlink" title="Find shortest path"></a>Find shortest path</h4><blockquote><p>single start shortest path in a aribitary directed non-negtive directed graph</p></blockquote><p>if a graph has negtive edges, this algorithm will lose effect</p><p>best: O(E + VlogV)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;spanning-tree&quot;&gt;&lt;a href=&quot;#spanning-tree&quot; class=&quot;headerlink&quot; title=&quot;spanning tree&quot;&gt;&lt;/a&gt;spanning tree&lt;/h4&gt;&lt;h5 id=&quot;Prim&quot;&gt;&lt;a href=&quot;#Prim&quot;
      
    
    </summary>
    
      <category term="CS400" scheme="http://yoursite.com/categories/CS400/"/>
    
    
  </entry>
  
  <entry>
    <title>The difference between int and Integer in Java</title>
    <link href="http://yoursite.com/2019/03/14/java_int_Integer%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/03/14/java_int_Integer区别/</id>
    <published>2019-03-14T21:54:21.738Z</published>
    <updated>2019-03-14T21:57:35.694Z</updated>
    
    <content type="html"><![CDATA[<h5 id="java-int与integer的区别"><a href="#java-int与integer的区别" class="headerlink" title="java int与integer的区别"></a>java int与integer的区别</h5><p>int与integer的区别从大的方面来说就是基本数据类型与其包装类的区别：</p><p>int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象</p><h6 id="1-Java-中的数据类型分为基本数据类型和复杂数据类型"><a href="#1-Java-中的数据类型分为基本数据类型和复杂数据类型" class="headerlink" title="1.Java 中的数据类型分为基本数据类型和复杂数据类型"></a>1.Java 中的数据类型分为基本数据类型和复杂数据类型</h6><p>int 是前者而integer 是后者（也就是一个类）；因此在类进行初始化时int类的变量初始为0.而Integer的变量则初始化为null.</p><h6 id="2-初始化时："><a href="#2-初始化时：" class="headerlink" title="2.初始化时："></a>2.初始化时：</h6><p>　　int i =1；Integer i= new Integer(1);(要把integer 当做一个类看)；但由于有了自动装箱和拆箱</p><p>　　使得对Integer类也可使用：Integer i= 1；　　　　   </p><p>　　int 是基本数据类型（面向过程留下的痕迹，不过是对java的有益补充），Integer 是一个类，是int的扩展，定义了很多的转换方法</p><p>　　类似的还有：float Float;double Double;string String等，而且还提供了处理 int 类型时非常有用的其他一些常量和方法</p><p>　　举个例子：当需要往ArrayList，HashMap中放东西时，像int，double这种内建类型是放不进去的，因为容器都是装 object的，这是就需要这些内建类型的外覆类了。</p><p>　　Java中每种内建类型都有相应的外覆类。</p><p>　　Java中int和Integer关系是比较微妙的。关系如下：</p><p>　　1.int是基本的数据类型；</p><p>　　2.Integer是int的封装类；</p><p>　　3.int和Integer都可以表示某一个数值；</p><p>　　4.int和Integer不能够互用，因为他们两种不同的数据类型；</p><p>　　举例说明<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　ArrayList al=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> n=<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">　　Integer nI=<span class="keyword">new</span> Integer(n);</span><br><span class="line"></span><br><span class="line">　　al.<span class="keyword">add</span>(n);<span class="comment">//不可以</span></span><br></pre></td></tr></table></figure></p><p>　　并且泛型定义时也不支持int: 如：List<integer> list = new ArrayList<integer>();可以  而List<int> list = new ArrayList<int>();则不行</int></int></integer></integer></p><h6 id="总而言之：如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解。"><a href="#总而言之：如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解。" class="headerlink" title="总而言之：如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解。"></a>总而言之：如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解。</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;java-int与integer的区别&quot;&gt;&lt;a href=&quot;#java-int与integer的区别&quot; class=&quot;headerlink&quot; title=&quot;java int与integer的区别&quot;&gt;&lt;/a&gt;java int与integer的区别&lt;/h5&gt;&lt;p&gt;in
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>hash_table</title>
    <link href="http://yoursite.com/2019/03/14/hash_table/"/>
    <id>http://yoursite.com/2019/03/14/hash_table/</id>
    <published>2019-03-14T21:37:54.004Z</published>
    <updated>2019-03-14T21:50:10.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hashtable-分open-addressing-和-chunked-chain，这里我们采用open-addressing-中的linear-probing。主要想记录一下踩到的四个坑"><a href="#hashtable-分open-addressing-和-chunked-chain，这里我们采用open-addressing-中的linear-probing。主要想记录一下踩到的四个坑" class="headerlink" title="hashtable 分open addressing 和 chunked chain，这里我们采用open addressing 中的linear probing。主要想记录一下踩到的四个坑"></a>hashtable 分open addressing 和 chunked chain，这里我们采用open addressing 中的linear probing。主要想记录一下踩到的四个坑</h4><h5 id="hashCode-method-我们来计算index的时候如下。"><a href="#hashCode-method-我们来计算index的时候如下。" class="headerlink" title="hashCode() method, 我们来计算index的时候如下。"></a>hashCode() method, 我们来计算index的时候如下。</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int keynumber</span> = key.hashCode();</span><br><span class="line"><span class="attribute">int index</span> = keynumber % Capacity;</span><br></pre></td></tr></table></figure><h5 id="1-对于double类型移位➕异或返回int-32位类型。对于string类型应该是"><a href="#1-对于double类型移位➕异或返回int-32位类型。对于string类型应该是" class="headerlink" title="1. 对于double类型移位➕异或返回int 32位类型。对于string类型应该是"></a>1. 对于double类型移位➕异或返回int 32位类型。对于string类型应该是</h5><p>$$<br>(int)s[0]*pow(31,n-1)<br>$$  </p><p>而不是</p><p>$$<br>(int)s[0]*pow(31,0)<br>$$</p><h5 id="2-对于这里的NullPointException-是因为没有检查当前node是否为null就直接调用node-key-因此会报错"><a href="#2-对于这里的NullPointException-是因为没有检查当前node是否为null就直接调用node-key-因此会报错" class="headerlink" title="2. 对于这里的NullPointException, 是因为没有检查当前node是否为null就直接调用node.key,  因此会报错"></a>2. 对于这里的NullPointException, 是因为没有检查当前node是否为null就直接调用node.key,  因此会报错</h5><h5 id="3-java中大小的比较，要用compare，equals而不要直接比较"><a href="#3-java中大小的比较，要用compare，equals而不要直接比较" class="headerlink" title="3. java中大小的比较，要用compare，equals而不要直接比较"></a>3. java中大小的比较，要用compare，equals而不要直接比较</h5><h5 id="4-对于hashtable中找一个不存在元素的情况。"><a href="#4-对于hashtable中找一个不存在元素的情况。" class="headerlink" title="4. 对于hashtable中找一个不存在元素的情况。"></a>4. 对于hashtable中找一个不存在元素的情况。</h5><p>假如不经过优化则会一直找，有的时候甚至会找O(n)。因此我们设立一个longestprobing，即冲突地址向前的最大长度，这样可以避免search整个数组，大大降低时间复杂度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hashtable-分open-addressing-和-chunked-chain，这里我们采用open-addressing-中的linear-probing。主要想记录一下踩到的四个坑&quot;&gt;&lt;a href=&quot;#hashtable-分open-addressin
      
    
    </summary>
    
      <category term="cs400" scheme="http://yoursite.com/categories/cs400/"/>
    
    
  </entry>
  
  <entry>
    <title>array problem</title>
    <link href="http://yoursite.com/2019/03/09/array_problem/"/>
    <id>http://yoursite.com/2019/03/09/array_problem/</id>
    <published>2019-03-09T22:33:45.343Z</published>
    <updated>2019-03-09T22:33:56.932Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2D-array-search-1-and-2D-array-search-2"><a href="#2D-array-search-1-and-2D-array-search-2" class="headerlink" title="2D array search 1  and  2D array search 2"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">2D array search 1 </a> and  <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">2D array search 2</a></h4><h5 id="对于1，整个数组完全排序，因此可以把二维的拉长，变成一维数组采用二分查找"><a href="#对于1，整个数组完全排序，因此可以把二维的拉长，变成一维数组采用二分查找" class="headerlink" title="对于1，整个数组完全排序，因此可以把二维的拉长，变成一维数组采用二分查找"></a>对于1，整个数组完全排序，因此可以把二维的拉长，变成一维数组采用二分查找</h5><h5 id="对于2，-我们必须要找到一个二分中间点"><a href="#对于2，-我们必须要找到一个二分中间点" class="headerlink" title="对于2， 我们必须要找到一个二分中间点"></a>对于2， 我们必须要找到一个二分中间点</h5><blockquote><p>为什么这么说呢，因为如果某一情况有两条路就需要用递归，而递归的过程中又可能回到之前的情况，从而形成死循环</p></blockquote><p>另外我们需要注意一个性质，对于（x，y），其右下角的数据全部大于他，其左下角的数据全部小于他。因此我们可以从数组的左下角开始，走到数组的右上角，就完成了查找</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="keyword">matrix</span>.<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(column == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = row <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &lt; column)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] &gt; target)&#123;</span><br><span class="line">                x --;<span class="comment">//意味着我们不需要从（x，y）的右下角找了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y ++;<span class="comment">//意味着我们不需要从（x，y）的左上角找了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;2D-array-search-1-and-2D-array-search-2&quot;&gt;&lt;a href=&quot;#2D-array-search-1-and-2D-array-search-2&quot; class=&quot;headerlink&quot; title=&quot;2D array searc
      
    
    </summary>
    
      <category term="array" scheme="http://yoursite.com/categories/array/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA 如何定义数组</title>
    <link href="http://yoursite.com/2019/03/05/Java_%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/05/Java_定义数组/</id>
    <published>2019-03-05T23:18:38.376Z</published>
    <updated>2019-03-05T23:18:38.376Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就google了一个怎么定义（key-value）数组。"><a href="#JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就google了一个怎么定义（key-value）数组。" class="headerlink" title="JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就google了一个怎么定义（key-value）数组。"></a>JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就google了一个怎么定义（key-value）数组。</h4><h4 id="首先你需要定义一个inner-class来储存key-value-pair，然后建立这个inner-class-的数组-注意看程序是怎么实现的"><a href="#首先你需要定义一个inner-class来储存key-value-pair，然后建立这个inner-class-的数组-注意看程序是怎么实现的" class="headerlink" title="首先你需要定义一个inner class来储存key-value pair，然后建立这个inner class 的数组,注意看程序是怎么实现的"></a>首先你需要定义一个inner class来储存key-value pair，然后建立这个inner class 的数组,注意看程序是怎么实现的</h4><blockquote><p>以后记住，对于generic的inner class，都在后面加入generic同样的参数，就可以愉快的定义啦～</p></blockquote><h4 id="同时别忘了，定义完数组以后，初始化。打个比方，如果是hashtable，你需要把这个数组初始化一圈，不然他虽然成功定义了，但是里面的全是null"><a href="#同时别忘了，定义完数组以后，初始化。打个比方，如果是hashtable，你需要把这个数组初始化一圈，不然他虽然成功定义了，但是里面的全是null" class="headerlink" title="同时别忘了，定义完数组以后，初始化。打个比方，如果是hashtable，你需要把这个数组初始化一圈，不然他虽然成功定义了，但是里面的全是null"></a>同时别忘了，定义完数组以后，初始化。打个比方，如果是hashtable，你需要把这个数组初始化一圈，不然他虽然成功定义了，但是里面的全是null</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> junyu</span></span><br><span class="line"><span class="comment"> * The goal here is to </span></span><br><span class="line"><span class="comment"> * 1. test generic class and its inner class</span></span><br><span class="line"><span class="comment"> * 2. try to set up the List of different types</span></span><br><span class="line"><span class="comment"> * 3. constructor don't need &lt;K,V&gt; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> &lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">arr = <span class="keyword">new</span> ArrayList&lt;hashPair&gt;(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">arr.add(<span class="keyword">new</span> hashPair()); <span class="comment">// array always need to be initialized</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span> List&lt;hashPair&gt; arr; <span class="comment">// this is similar to vector&lt;hashpair&gt; arr in c ++, </span></span><br><span class="line"><span class="comment">//if you want to build a bucket chained hash table, you can </span></span><br><span class="line"><span class="comment">//private List&lt;List&lt;hashPair&gt;&gt; hashList = new ArrayList&lt;List&lt;hashPair&gt;&gt;(10);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> junyu</span></span><br><span class="line"><span class="comment"> * 1. Build up the inner class, the goal of which is to build up the node storing the key-value pair</span></span><br><span class="line"><span class="comment"> * 2. Remember to add "&lt;K,V&gt;" or there will be mistakes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">hashPair</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">hashPair(K key, V value)&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">hashPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line"><span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> K key;</span><br><span class="line"><span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashPair[] haPairs = <span class="keyword">new</span> hashPair[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">test&lt;String, Integer&gt; test1Test = <span class="keyword">new</span> test&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.print(test1Test.arr.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) System.out.println(test1Test.arr.get(i).value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就google了一个怎么定义（key-value）数组。&quot;&gt;&lt;a href=&quot;#JAVA真是个磨人的老妖精，总是出现一些奇奇怪怪的报错，害得我一上午上完课什么也没干，就googl
      
    
    </summary>
    
      <category term="CS400" scheme="http://yoursite.com/categories/CS400/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode Heap, priority queue</title>
    <link href="http://yoursite.com/2019/03/03/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/03/优先队列/</id>
    <published>2019-03-03T23:46:27.183Z</published>
    <updated>2019-03-04T00:01:25.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-meeting-room"><a href="#Leetcode-meeting-room" class="headerlink" title="Leetcode meeting room"></a>Leetcode meeting room</h4><h3 id="这个问题来源于一道面试题：求无序不重复数组中第K大的数值-尽管可以用快排，但是heap是最优的，因为我们只需要对K个进行排序而不需要所有，因此我们来探究一下priority-queue（c-中对heap的包装，make-heap-heap-sort-heap-push）"><a href="#这个问题来源于一道面试题：求无序不重复数组中第K大的数值-尽管可以用快排，但是heap是最优的，因为我们只需要对K个进行排序而不需要所有，因此我们来探究一下priority-queue（c-中对heap的包装，make-heap-heap-sort-heap-push）" class="headerlink" title="这个问题来源于一道面试题：求无序不重复数组中第K大的数值,尽管可以用快排，但是heap是最优的，因为我们只需要对K个进行排序而不需要所有，因此我们来探究一下priority_queue（c++中对heap的包装，make_heap, heap_sort, heap_push）"></a>这个问题来源于一道面试题：求无序不重复数组中第K大的数值,尽管可以用快排，但是heap是最优的，因为我们只需要对K个进行排序而不需要所有，因此我们来探究一下priority_queue（c++中对heap的包装，make_heap, heap_sort, heap_push）</h3><h3 id="出于对快排的尊重，我们先来写一个快排-然后用优先队列"><a href="#出于对快排的尊重，我们先来写一个快排-然后用优先队列" class="headerlink" title="出于对快排的尊重，我们先来写一个快排, 然后用优先队列"></a>出于对快排的尊重，我们先来写一个快排, 然后用优先队列</h3><blockquote><p>快排又又又写错了，注意：1. 两边都是找绝对大于or绝对小于。2. 先右向左寻找，这样的话l，r将停留在一个小于pivot的地方 3. l在找到pivot之后不需要++</p></blockquote><h3 id="后来发现priority-queue这么好用，不如以后就用他了，省了很多事！但是要注意，如果说不从小到大排（意思是大元素在队出队），要自己定一个operator（queue的第三个参数，但同时要写入第二个参数（貌似是该类型的vector））"><a href="#后来发现priority-queue这么好用，不如以后就用他了，省了很多事！但是要注意，如果说不从小到大排（意思是大元素在队出队），要自己定一个operator（queue的第三个参数，但同时要写入第二个参数（貌似是该类型的vector））" class="headerlink" title="后来发现priority_queue这么好用，不如以后就用他了，省了很多事！但是要注意，如果说不从小到大排（意思是大元素在队出队），要自己定一个operator（queue的第三个参数，但同时要写入第二个参数（貌似是该类型的vector））"></a>后来发现priority_queue这么好用，不如以后就用他了，省了很多事！但是要注意，如果说不从小到大排（意思是大元素在队出队），要自己定一个operator（queue的第三个参数，但同时要写入第二个参数（貌似是该类型的vector））</h3><h3 id="相比之下，sort函数定义的只需要定一个bool函数即可"><a href="#相比之下，sort函数定义的只需要定一个bool函数即可" class="headerlink" title="- 相比之下，sort函数定义的只需要定一个bool函数即可"></a>- 相比之下，sort函数定义的只需要定一个bool函数即可</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by JunYu on 2018-12-30.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vector1, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = l;</span><br><span class="line">    <span class="keyword">int</span> end = r;</span><br><span class="line">    <span class="keyword">int</span> p = vector1[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(vector1[r] &gt;= p &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(vector1[l] &lt;= p &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(vector1[l], vector1[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(vector1[l], vector1[begin]);</span><br><span class="line">    quicksort(vector1, begin, l<span class="number">-1</span>);</span><br><span class="line">    quicksort(vector1, l + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a &gt; b means from bigger to smaller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// the goal is to find the K-minimal value in the list</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    quicksort(vector1, <span class="number">0</span>, vector1.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vector1[k<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// cout the outcome of quicksort</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, comp&gt; priority_queue1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector2.size(); i ++)&#123;</span><br><span class="line">        priority_queue1.push(vector2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">        priority_queue1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;priority_queue1.top(); <span class="comment">// the outcome of heap</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Leetcode-meeting-room&quot;&gt;&lt;a href=&quot;#Leetcode-meeting-room&quot; class=&quot;headerlink&quot; title=&quot;Leetcode meeting room&quot;&gt;&lt;/a&gt;Leetcode meeting room&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tree (AVL, Red-Black, B(2-3))</title>
    <link href="http://yoursite.com/2019/03/02/%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/02/树/</id>
    <published>2019-03-02T20:48:16.146Z</published>
    <updated>2019-03-02T20:48:16.146Z</updated>
    
    <content type="html"><![CDATA[<h5 id="AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便"><a href="#AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便" class="headerlink" title="AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便"></a>AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便</h5><blockquote><p>拥有一个内部结点key以及两个两个子结点，这个叫做<strong>2结点</strong>; 拥有两个内部结点key以及三个子结点，这个叫做<strong>3结点</strong> </p></blockquote><p><a href="https://drive.google.com/file/d/1Fm1NF2vJHWVIDFvnrCxi6d5aHtM9UnWw/view?usp=sharing" target="_blank" rel="noopener">这里有一个简单2-3树（B树的一种）的解释</a></p><p><a href="https://juejin.im/post/5b7e00456fb9a01a0b3193c7" target="_blank" rel="noopener">可以参考这里2-3Tree的插入过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便&quot;&gt;&lt;a href=&quot;#AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B-Tree(AVL, Red-Black, B(2-3))</title>
    <link href="http://yoursite.com/2019/03/01/B-tree/"/>
    <id>http://yoursite.com/2019/03/01/B-tree/</id>
    <published>2019-03-01T19:31:27.515Z</published>
    <updated>2019-03-03T23:59:56.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h3><blockquote><p>Balance factor显示了是否要进行旋转。BF = height_left - height_right</p></blockquote><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><h5 id="1-根结点必须是黑色"><a href="#1-根结点必须是黑色" class="headerlink" title="1. 根结点必须是黑色"></a>1. 根结点必须是黑色</h5><h5 id="2-红色结点的子结点必须是黑色"><a href="#2-红色结点的子结点必须是黑色" class="headerlink" title="2. 红色结点的子结点必须是黑色"></a>2. 红色结点的子结点必须是黑色</h5><h5 id="3-根结点到任意一个叶子结点路径上的黑色结点数相同"><a href="#3-根结点到任意一个叶子结点路径上的黑色结点数相同" class="headerlink" title="3. 根结点到任意一个叶子结点路径上的黑色结点数相同"></a>3. 根结点到任意一个叶子结点路径上的黑色结点数相同</h5><h4 id="How-to-fix"><a href="#How-to-fix" class="headerlink" title="How to fix"></a>How to fix</h4><blockquote><p>当违反了规则的时候，我们把它称为R.P.V(Red Properties Violation)</p></blockquote><blockquote><p>(<a href="https://github.com/JasonWang0808/blog_reference/blob/master/pictures/Red-black.png" target="_blank" rel="noopener">https://github.com/JasonWang0808/blog_reference/blob/master/pictures/Red-black.png</a>)</p></blockquote><h5 id="1-Recoloring-—-when-the-parent’s-sibling-is-red-but-you-need-recolor-the-root-to-be-black-in-the-end"><a href="#1-Recoloring-—-when-the-parent’s-sibling-is-red-but-you-need-recolor-the-root-to-be-black-in-the-end" class="headerlink" title="1. Recoloring — when the parent’s sibling is red, but you need recolor the root to be black in the end;"></a>1. Recoloring — when the parent’s sibling is red, but you need recolor the root to be black in the end;</h5><h5 id="2-Reconstruting-—-when-the-parent’s-sibling-is-black-or-null"><a href="#2-Reconstruting-—-when-the-parent’s-sibling-is-black-or-null" class="headerlink" title="2. Reconstruting — when the parent’s sibling is black or null"></a>2. Reconstruting — when the parent’s sibling is black or null</h5><h4 id="Hints"><a href="#Hints" class="headerlink" title="Hints:"></a>Hints:</h4><h5 id="1-每一次插入的都是红色"><a href="#1-每一次插入的都是红色" class="headerlink" title="1. 每一次插入的都是红色"></a>1. 每一次插入的都是红色</h5><h5 id="2-left-rotate-是指-Grandparent-变为parent的左孩子"><a href="#2-left-rotate-是指-Grandparent-变为parent的左孩子" class="headerlink" title="2. left-rotate 是指 Grandparent 变为parent的左孩子"></a>2. left-rotate 是指 Grandparent 变为parent的左孩子</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">G</span>.<span class="keyword">right</span> = <span class="type">P</span>.<span class="keyword">right</span>;</span><br><span class="line"><span class="type">P</span>.<span class="keyword">right</span> = <span class="type">G</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="type">P</span>; <span class="comment">// 返回新的根结点</span></span><br></pre></td></tr></table></figure><h5 id="3-复杂度全部为log-N-遍历还是n。"><a href="#3-复杂度全部为log-N-遍历还是n。" class="headerlink" title="3. 复杂度全部为log(N),遍历还是n。"></a>3. 复杂度全部为log(N),遍历还是n。</h5><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><h5 id="AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便"><a href="#AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便" class="headerlink" title="AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便"></a>AVL解决了BST插入不平衡的问题，但是要进行旋转，复杂度较高，因此提出2-3Tree，使得插入更加简便</h5><blockquote><p>拥有一个内部结点key以及两个两个子结点，这个叫做<strong>2结点</strong>; 拥有两个内部结点key以及三个子结点，这个叫做<strong>3结点</strong> </p></blockquote><h5 id="这里可以看到一个对B-Tree简单的笔记，介绍了性质"><a href="#这里可以看到一个对B-Tree简单的笔记，介绍了性质" class="headerlink" title="这里可以看到一个对B-Tree简单的笔记，介绍了性质"></a>这里可以看到一个对B-Tree简单的笔记，介绍了性质</h5><blockquote><p>(<a href="https://github.com/JasonWang0808/blog_reference/blob/master/pictures/Btree.png" target="_blank" rel="noopener">https://github.com/JasonWang0808/blog_reference/blob/master/pictures/Btree.png</a>)</p></blockquote><p><a href="https://juejin.im/post/5b7e00456fb9a01a0b3193c7" target="_blank" rel="noopener">可以参考这里2-3Tree的插入过程</a></p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B+ tree"></a>B+ tree</h3><blockquote><p>B+ tree是Btree的升级，主要改变在以下几个方面</p></blockquote><h4 id="B-tree独有的性质"><a href="#B-tree独有的性质" class="headerlink" title="B+ tree独有的性质"></a>B+ tree独有的性质</h4><h6 id="1-有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。"><a href="#1-有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。" class="headerlink" title="1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。"></a>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</h6><h6 id="2-所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。"><a href="#2-所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。" class="headerlink" title="2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。"></a>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</h6><h6 id="3-所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。"><a href="#3-所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。" class="headerlink" title="3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。"></a>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</h6><h4 id="B-Tree的好处"><a href="#B-Tree的好处" class="headerlink" title="B+ Tree的好处"></a>B+ Tree的好处</h4><h5 id="1-单一结点可以储存更多的元素，减少IO的次数"><a href="#1-单一结点可以储存更多的元素，减少IO的次数" class="headerlink" title="1. 单一结点可以储存更多的元素，减少IO的次数"></a>1. 单一结点可以储存更多的元素，减少IO的次数</h5><h5 id="2-所有的data（Satellite-Information）都存在叶结点，每一次的查询都很稳定"><a href="#2-所有的data（Satellite-Information）都存在叶结点，每一次的查询都很稳定" class="headerlink" title="2. 所有的data（Satellite Information）都存在叶结点，每一次的查询都很稳定"></a>2. 所有的data（Satellite Information）都存在叶结点，每一次的查询都很稳定</h5><h5 id="3-叶结点中有指针相互连接，使得查询某个范围中的数据集合更加方便（对于B树可能要不断回溯才能找到下一范围）"><a href="#3-叶结点中有指针相互连接，使得查询某个范围中的数据集合更加方便（对于B树可能要不断回溯才能找到下一范围）" class="headerlink" title="3. 叶结点中有指针相互连接，使得查询某个范围中的数据集合更加方便（对于B树可能要不断回溯才能找到下一范围）"></a>3. 叶结点中有指针相互连接，使得查询某个范围中的数据集合更加方便（对于B树可能要不断回溯才能找到下一范围）</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Red-Black-Tree&quot;&gt;&lt;a href=&quot;#Red-Black-Tree&quot; class=&quot;headerlink&quot; title=&quot;Red-Black Tree&quot;&gt;&lt;/a&gt;Red-Black Tree&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Balance f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode classical problem</title>
    <link href="http://yoursite.com/2019/03/01/leetocde_classic/"/>
    <id>http://yoursite.com/2019/03/01/leetocde_classic/</id>
    <published>2019-03-01T19:31:27.515Z</published>
    <updated>2019-03-01T19:31:27.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="big-number-multiply"><a href="#big-number-multiply" class="headerlink" title="big number multiply"></a>big number multiply</h3><blockquote><p>will over flow if you transfer them into number and do the product. </p></blockquote><h4 id="因此逐位相乘，下面这行代码可以说明一切"><a href="#因此逐位相乘，下面这行代码可以说明一切" class="headerlink" title="因此逐位相乘，下面这行代码可以说明一切"></a>因此逐位相乘，下面这行代码可以说明一切</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector1[i+j] = (string1[i] - <span class="string">'0'</span> * string2[i] - <span class="string">'0'</span>);// 利用了乘法的性质，把相同位数的加到一起</span><br><span class="line">// vector1中会存在有些元素比<span class="number">10</span>大，因此从尾到头遍历一遍，进行进位。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;big-number-multiply&quot;&gt;&lt;a href=&quot;#big-number-multiply&quot; class=&quot;headerlink&quot; title=&quot;big number multiply&quot;&gt;&lt;/a&gt;big number multiply&lt;/h3&gt;&lt;bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetocde回溯法(Back Tracking)</title>
    <link href="http://yoursite.com/2019/02/28/%E5%9B%9E%E6%BA%AF/"/>
    <id>http://yoursite.com/2019/02/28/回溯/</id>
    <published>2019-02-28T21:12:58.118Z</published>
    <updated>2019-02-28T21:15:07.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h3><h4 id="对于这种组合问题，只有三种情况"><a href="#对于这种组合问题，只有三种情况" class="headerlink" title="对于这种组合问题，只有三种情况"></a>对于这种组合问题，只有三种情况</h4><h4 id="1-（多次）选择当前"><a href="#1-（多次）选择当前" class="headerlink" title="1. （多次）选择当前"></a>1. （多次）选择当前</h4><h4 id="2-选择当前"><a href="#2-选择当前" class="headerlink" title="2. 选择当前"></a>2. 选择当前</h4><h4 id="3-不选当前"><a href="#3-不选当前" class="headerlink" title="3. 不选当前"></a>3. 不选当前</h4><h4 id="很多时候用递归，可能两个分支会递归到同一种状态，最后导致结果的重复（见下图）"><a href="#很多时候用递归，可能两个分支会递归到同一种状态，最后导致结果的重复（见下图）" class="headerlink" title="很多时候用递归，可能两个分支会递归到同一种状态，最后导致结果的重复（见下图）"></a>很多时候用递归，可能两个分支会递归到同一种状态，最后导致结果的重复（见下图）</h4><h4 id="因此我们可以将函数的主体改为一个for循环"><a href="#因此我们可以将函数的主体改为一个for循环" class="headerlink" title="因此我们可以将函数的主体改为一个for循环"></a>因此我们可以将函数的主体改为一个for循环</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(<span class="attribute">i </span>: I)&#123;</span><br><span class="line"><span class="selector-tag">vector1</span><span class="selector-class">.push_back</span>(i); <span class="comment">// 选择当前</span></span><br><span class="line"><span class="selector-tag">Solve</span>();<span class="comment">// 假定选择当前进行处理</span></span><br><span class="line"><span class="selector-tag">vector</span><span class="selector-class">.pop_back</span>(); <span class="comment">// 不选当前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-39-40-microsoft"><a href="#leetcode-39-40-microsoft" class="headerlink" title="leetcode 39, 40 (microsoft)"></a>leetcode 39, 40 (microsoft)</h4><blockquote><p>the goal is to find </p></blockquote><h5 id="39可以利用上面的方法进行求解。"><a href="#39可以利用上面的方法进行求解。" class="headerlink" title="39可以利用上面的方法进行求解。"></a>39可以利用上面的方法进行求解。</h5><h5 id="40-又多了一个trick"><a href="#40-又多了一个trick" class="headerlink" title="40 又多了一个trick"></a>40 又多了一个trick</h5><blockquote><p>[1,1,2,5,1] , 1+2+5 = 2+5+1 = 8,因此会得到相同的3组解。</p></blockquote><h5 id="我们把这个理解成，“只看个数”不看顺序，假如3个1中，出现了一个没选，那剩下的都不能选。"><a href="#我们把这个理解成，“只看个数”不看顺序，假如3个1中，出现了一个没选，那剩下的都不能选。" class="headerlink" title="我们把这个理解成，“只看个数”不看顺序，假如3个1中，出现了一个没选，那剩下的都不能选。"></a>我们把这个理解成，“只看个数”不看顺序，假如3个1中，出现了一个没选，那剩下的都不能选。</h5><blockquote><p>比如牛肉面加肉，有三块牛腩可以加。但是第一块很小，第二块中等，第三块最大。每一块价格相同，不能跳着选。要想吃到第三块牛肉就要把第一块第二块都选中。 中途放弃的后面的也别想要。这就是这个题如何避免重复解的原理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;出错原因&quot;&gt;&lt;a href=&quot;#出错原因&quot; class=&quot;headerlink&quot; title=&quot;出错原因&quot;&gt;&lt;/a&gt;出错原因&lt;/h3&gt;&lt;h4 id=&quot;对于这种组合问题，只有三种情况&quot;&gt;&lt;a href=&quot;#对于这种组合问题，只有三种情况&quot; class=&quot;header
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Data Structure(4) The using of Set/map(hash_table)</title>
    <link href="http://yoursite.com/2019/01/08/DS_SetMap/"/>
    <id>http://yoursite.com/2019/01/08/DS_SetMap/</id>
    <published>2019-01-08T06:48:05.113Z</published>
    <updated>2019-03-09T22:53:26.261Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Set的使用"><a href="#1-Set的使用" class="headerlink" title="1. Set的使用"></a>1. Set的使用</h4><h5 id="可以当作hash-table进行使用"><a href="#可以当作hash-table进行使用" class="headerlink" title="可以当作hash table进行使用"></a>可以当作hash table进行使用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.find(nums[i]) == hashtable.end())&#123;<span class="comment">// 相当于在hash table中按照index寻找</span></span><br><span class="line">                hashtable.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hashtable.erase(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *hashtable.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>可用于储存在计算过程中的过程，leetcode202 happy number就需要储存计算中曾经出现过哪些数字。</p></blockquote><p>使用insert排着插入即可</p><blockquote><p>Leetcode 349求补集<br>注意vector和set之间可以直接一键转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1(s1.begin(), s1.end());</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="2-map实际上也是hash-table的一种体现"><a href="#2-map实际上也是hash-table的一种体现" class="headerlink" title="2. map实际上也是hash_table的一种体现"></a>2. map实际上也是hash_table的一种体现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 注意定义方式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            m[nums[i]] = i; <span class="comment">//直接像数组一样添加就可以</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.find(target-nums[i]) != m.end())&#123; <span class="comment">// hash_table的映射函数</span></span><br><span class="line">                <span class="keyword">if</span>(i != m[target-nums[i]])&#123;</span><br><span class="line">                    res.push_back(m[target-nums[i]]);</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h4><p>map和set在底层都是一棵平衡二叉树，有unordered_map和unordered_set底层是哈希表实现<br>而ordered_map 和ordered_set是Red-Black实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Set的使用&quot;&gt;&lt;a href=&quot;#1-Set的使用&quot; class=&quot;headerlink&quot; title=&quot;1. Set的使用&quot;&gt;&lt;/a&gt;1. Set的使用&lt;/h4&gt;&lt;h5 id=&quot;可以当作hash-table进行使用&quot;&gt;&lt;a href=&quot;#可以当作hash-
      
    
    </summary>
    
      <category term="DS" scheme="http://yoursite.com/categories/DS/"/>
    
    
  </entry>
  
  <entry>
    <title>Data Structure(1) Linked List</title>
    <link href="http://yoursite.com/2019/01/07/DT_LinkedList1/"/>
    <id>http://yoursite.com/2019/01/07/DT_LinkedList1/</id>
    <published>2019-01-08T00:57:45.895Z</published>
    <updated>2019-01-08T00:57:45.896Z</updated>
    
    <content type="html"><![CDATA[<ol start="206"><li>Reverse Linked List</li><li>Reverse Linked List 2<br>考察链表的指针操作  </li></ol><p>Notes: 要充分注意首尾是否指针为空</p><p>Tips：<strong>虚拟头节点</strong></p><blockquote><p>可以定义一个dummyHead作为head前面的标志性指针, 好处是，不管head怎样变化，只要调用其next总能找到现在的head（203，82）</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode *dummyHead = ListNode(-<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">dummyHead-&gt;next = head<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>对于特定的92号问题，反转链表，我们可以通过一个函数返回两个数据：  </p><ol><li>最左边的元素  </li><li>原本最左边的元素的next</li></ol><p>在链表中穿针引线（23，24，124，125， 237）<br>双指针（61，143，234，19）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;206&quot;&gt;
&lt;li&gt;Reverse Linked List&lt;/li&gt;
&lt;li&gt;Reverse Linked List 2&lt;br&gt;考察链表的指针操作  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notes: 要充分注意首尾是否指针为空&lt;/p&gt;
&lt;p&gt;Tips：&lt;stron
      
    
    </summary>
    
      <category term="DT" scheme="http://yoursite.com/categories/DT/"/>
    
    
      <category term="DT" scheme="http://yoursite.com/tags/DT/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure(1) Linked List</title>
    <link href="http://yoursite.com/2019/01/07/DS_LinkedList/"/>
    <id>http://yoursite.com/2019/01/07/DS_LinkedList/</id>
    <published>2019-01-07T16:12:50.611Z</published>
    <updated>2019-01-08T06:49:32.671Z</updated>
    
    <content type="html"><![CDATA[<ol start="206"><li>Reverse Linked List</li><li>Reverse Linked List 2<br>考察链表的指针操作  </li></ol><p>Notes: 要充分注意首尾是否指针为空</p><p>Tips：<strong>虚拟头节点</strong></p><blockquote><p>可以定义一个dummyHead作为head前面的标志性指针, 好处是，不管head怎样变化，只要调用其next总能找到现在的head（203，82）</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode *dummyHead = ListNode(-<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">dummyHead-&gt;next = head<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>对于特定的92号问题，反转链表，我们可以通过一个函数返回两个数据：  </p><ol><li>最左边的元素  </li><li>原本最左边的元素的next</li></ol><p>在链表中穿针引线（23，24，124，125， 237）<br>双指针（61，143，234，19）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;206&quot;&gt;
&lt;li&gt;Reverse Linked List&lt;/li&gt;
&lt;li&gt;Reverse Linked List 2&lt;br&gt;考察链表的指针操作  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notes: 要充分注意首尾是否指针为空&lt;/p&gt;
&lt;p&gt;Tips：&lt;stron
      
    
    </summary>
    
      <category term="DS" scheme="http://yoursite.com/categories/DS/"/>
    
    
      <category term="DS" scheme="http://yoursite.com/tags/DS/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure(2) Stack VS queue</title>
    <link href="http://yoursite.com/2019/01/07/DS_stack/"/>
    <id>http://yoursite.com/2019/01/07/DS_stack/</id>
    <published>2019-01-07T15:33:05.416Z</published>
    <updated>2019-01-09T15:12:54.354Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h4><h5 id="Stack，又名堆，后进先出问题。非常经典的一个括号匹配问题就是出自Stack之手。"><a href="#Stack，又名堆，后进先出问题。非常经典的一个括号匹配问题就是出自Stack之手。" class="headerlink" title="Stack，又名堆，后进先出问题。非常经典的一个括号匹配问题就是出自Stack之手。"></a>Stack，又名堆，后进先出问题。非常经典的一个括号匹配问题就是出自Stack之手。</h5><h5 id="Queue，又名队列，先进先出，常用于对“TreeNode”的层级问题的解答，因为每一层都可以看作是一个队列来进行处理。常用Vector-lt-Vector-gt-来进行计算"><a href="#Queue，又名队列，先进先出，常用于对“TreeNode”的层级问题的解答，因为每一层都可以看作是一个队列来进行处理。常用Vector-lt-Vector-gt-来进行计算" class="headerlink" title="Queue，又名队列，先进先出，常用于对“TreeNode”的层级问题的解答，因为每一层都可以看作是一个队列来进行处理。常用Vector&lt;Vector&gt;来进行计算"></a>Queue，又名队列，先进先出，常用于对“TreeNode”的层级问题的解答，因为每一层都可以看作是一个队列来进行处理。常用Vector&lt;Vector<int>&gt;来进行计算</int></h5><blockquote><p>102,103,104,199都可以用队列来解答</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack常用用法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt; pair &lt;Node*, <span class="keyword">int</span>&gt;&gt; s1; <span class="comment">//设立一个包含pair的Stack  </span></span><br><span class="line">s1.top();</span><br><span class="line">s1.push_back();</span><br><span class="line">s1.pop();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue常用用法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;&lt; pair &lt;Node*, <span class="keyword">int</span>&gt;&gt; q1; <span class="comment">//设立一个包含pair的Stack  </span></span><br><span class="line">s1.top();</span><br><span class="line">s1.push();</span><br><span class="line">s1.pop();</span><br></pre></td></tr></table></figure><h4 id="二、图论应用"><a href="#二、图论应用" class="headerlink" title="二、图论应用"></a>二、图论应用</h4><blockquote><p>类似练习127，126<br>例如leetcode279题，寻找相加平方数最少的一种方案。<br>我们可以将其想像成求无权边的最短路径，使用BFS</p></blockquote><blockquote><p>例如计算9，首先8–&gt;9(1), 5–&gt;9(2), 0–&gt;9(3) , 9就连接了三个顶点分别是0,5,8</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Leetcode279</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isvisit(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        isvisit[n] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; queue1;</span><br><span class="line">        queue1.push(make_pair(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue1.empty() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> Node_n = queue1.front().first;</span><br><span class="line">            <span class="keyword">int</span> dis = queue1.front().second;</span><br><span class="line">            queue1.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = i * i;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; Node_n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp == Node_n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> dis + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isvisit[Node_n - temp] == <span class="number">0</span> )&#123;</span><br><span class="line">                        queue1.push(make_pair(Node_n - temp, dis+<span class="number">1</span>));</span><br><span class="line">                        isvisit[Node_n - temp] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="三、优先队列"><a href="#三、优先队列" class="headerlink" title="三、优先队列"></a>三、优先队列</h4><p>优先队列其实就是一个堆，只是能应用的逻辑相对比较简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt; pq1(mycmp);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycpmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b; <span class="comment">//大的元素在队列首</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：Leetcode347。</p><p>Tips：  </p><ol><li>建立一个map，类似Wordcount</li><li>队列的pair运用第一个元素比较，因此要把pair的第一个元素设置成频率。  </li><li>while循环别把empty的标志设置反</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        assert(k &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size() ; i ++)&#123;</span><br><span class="line">            freq[nums[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(k &lt;= freq.size());</span><br><span class="line"></span><br><span class="line">        priority_queue&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = freq.begin() ; iter != freq.end() ; iter ++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pq.size() == k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;second &gt; pq.top().first)&#123;</span><br><span class="line">                    pq.pop();</span><br><span class="line">                    pq.push(make_pair(iter-&gt;second, iter-&gt;first));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pq.push(make_pair(iter-&gt;second, iter-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            res.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、基本介绍&quot;&gt;&lt;a href=&quot;#一、基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基本介绍&quot;&gt;&lt;/a&gt;一、基本介绍&lt;/h4&gt;&lt;h5 id=&quot;Stack，又名堆，后进先出问题。非常经典的一个括号匹配问题就是出自Stack之手。&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="DS" scheme="http://yoursite.com/categories/DS/"/>
    
    
  </entry>
  
  <entry>
    <title>收到offer之后的申请流程</title>
    <link href="http://yoursite.com/2018/11/27/wisc_prepare/"/>
    <id>http://yoursite.com/2018/11/27/wisc_prepare/</id>
    <published>2018-11-27T11:50:28.000Z</published>
    <updated>2018-11-27T11:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们这里以UW-Madison为例讲一下留学得到offer后的操作"><a href="#我们这里以UW-Madison为例讲一下留学得到offer后的操作" class="headerlink" title="我们这里以UW-Madison为例讲一下留学得到offer后的操作"></a>我们这里以UW-Madison为例讲一下留学得到offer后的操作</h3><h4 id="先给出一个流程图，大概说一下整个的流程"><a href="#先给出一个流程图，大概说一下整个的流程" class="headerlink" title="先给出一个流程图，大概说一下整个的流程"></a>先给出一个流程图，大概说一下整个的流程</h4><p> <img src="/images/qianzheng/process.jpg" width="300" height="200" alt="img1" align="center"></p><h4 id="1-首先要做的当然是Accept-offer"><a href="#1-首先要做的当然是Accept-offer" class="headerlink" title="1. 首先要做的当然是Accept offer"></a>1. 首先要做的当然是<strong>Accept offer</strong></h4><h4 id="2-接着我们需要拿到一个叫做I-20的文件（这个每个学校的操作可能各有不同）"><a href="#2-接着我们需要拿到一个叫做I-20的文件（这个每个学校的操作可能各有不同）" class="headerlink" title="2. 接着我们需要拿到一个叫做I-20的文件（这个每个学校的操作可能各有不同）"></a>2. 接着我们需要拿到一个叫做I-20的文件（这个每个学校的操作可能各有不同）</h4><blockquote><p><a href="https://www.admissions.wisc.edu/admitted/checklist/spring_international.php" target="_blank" rel="noopener">Checklist 4. 中列出了需要的文件</a></p></blockquote><h4 id="申请I20在UW-Madison一共需要4个文件"><a href="#申请I20在UW-Madison一共需要4个文件" class="headerlink" title="申请I20在UW-Madison一共需要4个文件"></a>申请I20在UW-Madison一共需要4个文件</h4><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.admissions.wisc.edu/assets/pdfs/UW_Financial_Verification_Form.pdf" target="_blank" rel="noopener">Financial Verification Form</a></li><li style="list-style: none"><input type="checkbox" checked> 存款证明</li><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.admissions.wisc.edu/assets/pdfs/UW_VISA_Form.pdf/" target="_blank" rel="noopener">Student Visa Information and Mailing Form</a></li><li style="list-style: none"><input type="checkbox" checked> Copies of passport pages showing your identity and full legal name</li></ul><h5 id="准备好了四个文件，将pdf发给onwisconsin-admissions-wisc-edu就结束了I20的申请"><a href="#准备好了四个文件，将pdf发给onwisconsin-admissions-wisc-edu就结束了I20的申请" class="headerlink" title="准备好了四个文件，将pdf发给onwisconsin@admissions.wisc.edu就结束了I20的申请"></a>准备好了四个文件，将pdf发给<a href="mailto:onwisconsin@admissions.wisc.edu" target="_blank" rel="noopener">onwisconsin@admissions.wisc.edu</a>就结束了I20的申请</h5><h4 id="3-等待I-20，这是一个漫长的过程，大概需要两个半星期"><a href="#3-等待I-20，这是一个漫长的过程，大概需要两个半星期" class="headerlink" title="3. 等待I-20，这是一个漫长的过程，大概需要两个半星期"></a>3. 等待I-20，这是一个漫长的过程，大概需要两个半星期</h4><h4 id="4-1-拿到I-20之后就要申请F-1签证了"><a href="#4-1-拿到I-20之后就要申请F-1签证了" class="headerlink" title="4.1 拿到I-20之后就要申请F-1签证了"></a>4.1 拿到I-20之后就要申请F-1签证了</h4><blockquote><p>这里UW-Madison给出了一些<a href="https://www.admissions.wisc.edu/assets/pdfs/obtainvisa.pdf" target="_blank" rel="noopener">F-1签证的tips</a></p></blockquote><p>但是个人感觉上述说的不是很具体，这里给出两个比较生动形象的公众号贴文 (<a href="https://mp.weixin.qq.com/s/-tSUKd-a01NGkra7UxZx0w" target="_blank" rel="noopener">文章1</a>，<a href="https://mp.weixin.qq.com/s/1mStu5ztzIugQR8D7Hkp7Q" target="_blank" rel="noopener">文章2</a>)<br>看完这两个文章，并准备好相应的材料就可以预约面签了  </p><h4 id="4-2-与此同时我们应该开始准备Placement-Test了"><a href="#4-2-与此同时我们应该开始准备Placement-Test了" class="headerlink" title="4.2 与此同时我们应该开始准备Placement Test了"></a>4.2 与此同时我们应该开始准备Placement Test了</h4><blockquote><p><a href="https://exams.wisc.edu/placement/uw-madison-students.php" target="_blank" rel="noopener">这里是FAQ</a>  届时会有邮件通知我们需要参加什么类别的考试<br>点击-&gt; <a href="https://exams.wisc.edu/placement/regionaltesting/information.php" target="_blank" rel="noopener">进入注册placement test</a>  </p></blockquote><blockquote><p><a href="https://soar.wisc.edu/" target="_blank" rel="noopener">同样可以在SOAR 2.中看到详细信息</a>  </p></blockquote><h4 id="5-拿到F-1签证准备好行李顺顺利利去上学"><a href="#5-拿到F-1签证准备好行李顺顺利利去上学" class="headerlink" title="5. 拿到F-1签证准备好行李顺顺利利去上学"></a>5. 拿到F-1签证准备好行李顺顺利利去上学</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我们这里以UW-Madison为例讲一下留学得到offer后的操作&quot;&gt;&lt;a href=&quot;#我们这里以UW-Madison为例讲一下留学得到offer后的操作&quot; class=&quot;headerlink&quot; title=&quot;我们这里以UW-Madison为例讲一下留学得到of
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>how to use Ubuntu and Git to push projects</title>
    <link href="http://yoursite.com/2018/11/19/Ubuntu-git/"/>
    <id>http://yoursite.com/2018/11/19/Ubuntu-git/</id>
    <published>2018-11-19T12:28:46.000Z</published>
    <updated>2019-01-29T05:22:11.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Step1-配置SSH-key并输入到github上"><a href="#Step1-配置SSH-key并输入到github上" class="headerlink" title="Step1. 配置SSH key并输入到github上"></a>Step1. 配置SSH key并输入到github上</h3><blockquote><p>见下面</p></blockquote><h3 id="Step2-手动添加仓库或者直接clone"><a href="#Step2-手动添加仓库或者直接clone" class="headerlink" title="Step2. 手动添加仓库或者直接clone"></a>Step2. <a href="https://blog.csdn.net/chenguolinblog/article/details/19929509" target="_blank" rel="noopener">手动添加仓库或者直接clone</a></h3><h3 id="Step3-添加成为contributor"><a href="#Step3-添加成为contributor" class="headerlink" title="Step3. 添加成为contributor"></a>Step3. <a href="https://segmentfault.com/a/1190000015798490" target="_blank" rel="noopener">添加成为contributor</a></h3><p>首先下载git，这个不用我说了<br>在github上建立一个名字为XXX的仓库作为你要托管的对象，这里我采用learn-repo作为我的名字  </p><blockquote><p>JasonWang0808/Learn-repo</p></blockquote><p>在Ubuntu下生成SSH key来连接自己的github，可以参考<a href="https://segmentfault.com/a/1190000013154540" target="_blank" rel="noopener">这个博文</a>, 此处也不啰嗦  </p><p>接下来在ubuntu中建立一个文件夹作为本地仓库</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 初始化</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta"># 建立文件（以及做出类似改动）</span></span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="meta"># 提交本次的改动，注意后面的注释参数不要拉下</span></span><br><span class="line">git commit -m <span class="string">'first_commit'</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 建立远程连接 origin就是仓库名字而已，允许修改</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/JasonWang0808/learn-repo.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 将新的仓库内容push到刚刚命名的origin，并且为master分支  </span></span><br><span class="line">git push origin master</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><p>遇到的坑</p><ol><li>直接复制文件夹过来上传后是灰色的</li></ol><blockquote><p>不知道为啥，自己新建然后cp吧</p></blockquote><ol start="2"><li>报错：error:failed to push som refs to……</li></ol><blockquote><p>git pull –rebase origin master   可能是本地和远程有区别等原因</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Step1-配置SSH-key并输入到github上&quot;&gt;&lt;a href=&quot;#Step1-配置SSH-key并输入到github上&quot; class=&quot;headerlink&quot; title=&quot;Step1. 配置SSH key并输入到github上&quot;&gt;&lt;/a&gt;Step1. 
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hidden Markov Model，HMM</title>
    <link href="http://yoursite.com/2018/11/18/HMM/"/>
    <id>http://yoursite.com/2018/11/18/HMM/</id>
    <published>2018-11-19T02:25:44.000Z</published>
    <updated>2018-11-19T02:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>  <h3 id="隐马尔可夫模型在词性标注上的应用"><a href="#隐马尔可夫模型在词性标注上的应用" class="headerlink" title="隐马尔可夫模型在词性标注上的应用"></a>隐马尔可夫模型在词性标注上的应用</h3><blockquote><p>给定前提我们只关注N/M/V三个词性  </p></blockquote><h4 id="首先介绍第一个概念-Emission-Probabilities"><a href="#首先介绍第一个概念-Emission-Probabilities" class="headerlink" title="首先介绍第一个概念  Emission Probabilities"></a>首先介绍第一个概念  Emission Probabilities</h4><h4 id="gt-是指同一种状态各个数值得可能性，可以看下图"><a href="#gt-是指同一种状态各个数值得可能性，可以看下图" class="headerlink" title="&gt; 是指同一种状态各个数值得可能性，可以看下图"></a>&gt; 是指同一种状态各个数值得可能性，可以看下图</h4><p><img src="/images/NLP/HMM/1.png" alt="">  </p><h4 id="我们可以看到，当认为是当前词语是N的时候有4-9的可能性是mary"><a href="#我们可以看到，当认为是当前词语是N的时候有4-9的可能性是mary" class="headerlink" title="我们可以看到，当认为是当前词语是N的时候有4/9的可能性是mary"></a>我们可以看到，当认为是当前词语是N的时候有4/9的可能性是mary</h4><h4 id="接下来是第二个概念-Transition-Probabilities"><a href="#接下来是第二个概念-Transition-Probabilities" class="headerlink" title="接下来是第二个概念  Transition Probabilities"></a>接下来是第二个概念  Transition Probabilities</h4><h4 id="gt-指状态之间的转换概率，S-E分别表示开始和结束，看下图"><a href="#gt-指状态之间的转换概率，S-E分别表示开始和结束，看下图" class="headerlink" title="&gt; 指状态之间的转换概率，S/E分别表示开始和结束，看下图"></a>&gt; 指状态之间的转换概率，S/E分别表示开始和结束，看下图</h4><p><img src="/images/NLP/HMM/2.png" alt="">  </p><h4 id="OK，那我们先来看一个例子"><a href="#OK，那我们先来看一个例子" class="headerlink" title="OK，那我们先来看一个例子"></a>OK，那我们先来看一个例子</h4><blockquote><p>Jane will spot Will  </p></blockquote><h4 id="我们根据前序经验统计出前面的两个概率，然后可以构造流程图如下"><a href="#我们根据前序经验统计出前面的两个概率，然后可以构造流程图如下" class="headerlink" title="我们根据前序经验统计出前面的两个概率，然后可以构造流程图如下"></a>我们根据前序经验统计出前面的两个概率，然后可以构造流程图如下</h4><p><img src="/images/NLP/HMM/3.png" alt="">   </p><h4 id="我们要计算每一条链的可能性就是把边数值与节点数值一路相乘，为了减少计算，我们采用每一层的动态规划（就是最简单那种），每个节点只保留前序节点数值最大的那一条。"><a href="#我们要计算每一条链的可能性就是把边数值与节点数值一路相乘，为了减少计算，我们采用每一层的动态规划（就是最简单那种），每个节点只保留前序节点数值最大的那一条。" class="headerlink" title="我们要计算每一条链的可能性就是把边数值与节点数值一路相乘，为了减少计算，我们采用每一层的动态规划（就是最简单那种），每个节点只保留前序节点数值最大的那一条。"></a>我们要计算每一条链的可能性就是把边数值与节点数值一路相乘，为了减少计算，我们采用每一层的动态规划（就是最简单那种），每个节点只保留前序节点数值最大的那一条。</h4><h4 id="最后我们就可以得到这样一条-通过分析我们可以发现确实得到的结果和我们预期相同"><a href="#最后我们就可以得到这样一条-通过分析我们可以发现确实得到的结果和我们预期相同" class="headerlink" title="最后我们就可以得到这样一条,通过分析我们可以发现确实得到的结果和我们预期相同"></a>最后我们就可以得到这样一条,通过分析我们可以发现确实得到的结果和我们预期相同</h4><h2 id=""><a href="#" class="headerlink" title="   "></a><img src="/images/NLP/HMM/3.png" alt="">   </h2><h3 id="以上是找best-path，接下来我们看一下HMM的forward-algorithm"><a href="#以上是找best-path，接下来我们看一下HMM的forward-algorithm" class="headerlink" title="以上是找best path，接下来我们看一下HMM的forward algorithm"></a>以上是找best path，接下来我们看一下HMM的forward algorithm</h3><hr><p>已知概率分布  </p><p><strong>1. Initial</strong></p><table><thead><tr><th>Sunny</th><th>Rainy</th></tr></thead><tbody><tr><td>0.5</td><td>0.5</td></tr></tbody></table><p><strong>2. Emission Probabilities</strong></p><table><thead><tr><th>null</th><th>yes</th><th>no</th></tr></thead><tbody><tr><td>sunny</td><td>0.1</td><td>0.9</td></tr><tr><td>rainy</td><td>0.8</td><td>0.2</td></tr></tbody></table><p><strong>3. State transition probabilities</strong></p><table><thead><tr><th>null</th><th>sunny</th><th>rainy</th></tr></thead><tbody><tr><td>sunny</td><td>0.8</td><td>0.2</td></tr><tr><td>rainy</td><td>0.4</td><td>0.6  </td></tr></tbody></table><h5 id="现在给定一个序列-S-‘yes’-‘no’-‘yes’"><a href="#现在给定一个序列-S-‘yes’-‘no’-‘yes’" class="headerlink" title="现在给定一个序列 S = [‘yes’, ‘no’, ‘yes’]"></a>现在给定一个序列 S = [‘yes’, ‘no’, ‘yes’]</h5><h5 id="通过forward-algorithm可以计算出在所有的天气组合当中所有满足该序列的概率"><a href="#通过forward-algorithm可以计算出在所有的天气组合当中所有满足该序列的概率" class="headerlink" title="通过forward algorithm可以计算出在所有的天气组合当中所有满足该序列的概率\"></a>通过forward algorithm可以计算出在所有的天气组合当中所有满足该序列的概率\</h5><p>$$<br>P(S|1-sunny) = 0.5 * 0.1 = 0.05<br>$$</p><p>$$<br>P(S|1-rainy) = 0.5 * 0.8 = 0.4<br>$$</p><p>$$<br>P(S|2-sunny) = (P(S|1-sunny)*0.8 + P(S|1-rainy)*0.4)P(no|sunny)<br>$$</p><h4 id="以此类推，最终结果为-P-S-3-sunny-P-S-3-rainy"><a href="#以此类推，最终结果为-P-S-3-sunny-P-S-3-rainy" class="headerlink" title="以此类推，最终结果为\(P(S|3-sunny) + P(S|3-rainy)\)"></a>以此类推，最终结果为\(P(S|3-sunny) + P(S|3-rainy)\)</h4><h4 id="我们可以看出来这个过程相当繁琐-这里用pomegranate库来实现"><a href="#我们可以看出来这个过程相当繁琐-这里用pomegranate库来实现" class="headerlink" title="我们可以看出来这个过程相当繁琐, 这里用pomegranate库来实现"></a>我们可以看出来这个过程相当繁琐, 这里用pomegranate库来实现</h4><blockquote><p>参考的问题是关于一个海藻的理论推导 <a href="https://blog.csdn.net/TH_NUM/article/details/51570174" target="_blank" rel="noopener">https://blog.csdn.net/TH_NUM/article/details/51570174</a></p></blockquote><h4 id="为什么和手动算的结果有些偏差呢，因为这个每一步都会进行估算"><a href="#为什么和手动算的结果有些偏差呢，因为这个每一步都会进行估算" class="headerlink" title="为什么和手动算的结果有些偏差呢，因为这个每一步都会进行估算"></a>为什么和手动算的结果有些偏差呢，因为这个每一步都会进行估算</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">from pomegranate import State, HiddenMarkovModel, <span class="keyword">DiscreteDistribution</span></span><br><span class="line"><span class="keyword">import </span>numpy as np</span><br><span class="line">model = HiddenMarkovModel(name=<span class="string">"Example Model"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每个状态的发射概率</span></span><br><span class="line">sunny_emissions = <span class="keyword">DiscreteDistribution(&#123;"Dry": </span><span class="number">0</span>.<span class="number">6</span>, <span class="string">"Dryish"</span>: <span class="number">0</span>.<span class="number">2</span>, <span class="string">"Damp"</span>:<span class="number">0</span>.<span class="number">15</span>, <span class="string">"Soggy"</span>:<span class="number">0</span>.<span class="number">05</span>&#125;)</span><br><span class="line">sunny_state = State(sunny_emissions, name=<span class="string">"Sunny"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">cloud_emissions </span>= <span class="keyword">DiscreteDistribution(&#123;"Dry": </span><span class="number">0</span>.<span class="number">25</span>, <span class="string">"Dryish"</span>: <span class="number">0</span>.<span class="number">25</span>, <span class="string">"Damp"</span>:<span class="number">0</span>.<span class="number">25</span>, <span class="string">"Soggy"</span>:<span class="number">0</span>.<span class="number">25</span>&#125;)</span><br><span class="line"><span class="keyword">cloud_state </span>= State(<span class="keyword">cloud_emissions, </span>name=<span class="string">"Cloud"</span>)</span><br><span class="line"></span><br><span class="line">rainy_emissions = <span class="keyword">DiscreteDistribution(&#123;"Dry": </span><span class="number">0</span>.<span class="number">05</span>, <span class="string">"Dryish"</span>: <span class="number">0</span>.<span class="number">10</span>, <span class="string">"Damp"</span>:<span class="number">0</span>.<span class="number">35</span>, <span class="string">"Soggy"</span>:<span class="number">0</span>.<span class="number">50</span>&#125;)</span><br><span class="line">rainy_state = State(rainy_emissions, name=<span class="string">"Rainy"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="keyword">cloud_emissions.probability("Dryish"))</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"># </span>添加状态</span><br><span class="line">model.<span class="keyword">add_states(sunny_state, </span><span class="keyword">cloud_state, </span>rainy_state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加转移概率，从init开始</span></span><br><span class="line">model.<span class="keyword">add_transition(model.start, </span>sunny_state, <span class="number">0</span>.<span class="number">63</span>)</span><br><span class="line">model.<span class="keyword">add_transition(model.start, </span>rainy_state, <span class="number">0</span>.<span class="number">20</span>)</span><br><span class="line">model.<span class="keyword">add_transition(model.start, </span><span class="keyword">cloud_state, </span><span class="number">0</span>.<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.<span class="keyword">add_transition(sunny_state, </span>sunny_state, <span class="number">0</span>.<span class="number">5</span>)  <span class="comment"># 50% sunny-&gt;sunny</span></span><br><span class="line">model.<span class="keyword">add_transition(sunny_state, </span>rainy_state, <span class="number">0</span>.<span class="number">125</span>)  <span class="comment"># 12.5% sunny-&gt;rainy</span></span><br><span class="line">model.<span class="keyword">add_transition(sunny_state, </span><span class="keyword">cloud_state, </span><span class="number">0</span>.<span class="number">375</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.<span class="keyword">add_transition(rainy_state, </span>sunny_state, <span class="number">0</span>.<span class="number">25</span>)  <span class="comment"># 25% rainy-&gt;sunny</span></span><br><span class="line">model.<span class="keyword">add_transition(rainy_state, </span>rainy_state, <span class="number">0</span>.<span class="number">375</span>)  <span class="comment"># 37.5% rainy-&gt;rainy</span></span><br><span class="line">model.<span class="keyword">add_transition(rainy_state, </span><span class="keyword">cloud_state, </span><span class="number">0</span>.<span class="number">375</span>)</span><br><span class="line"></span><br><span class="line">model.<span class="keyword">add_transition(cloud_state, </span><span class="keyword">cloud_state, </span><span class="number">0</span>.<span class="number">125</span>)</span><br><span class="line">model.<span class="keyword">add_transition(cloud_state, </span>sunny_state, <span class="number">0</span>.<span class="number">25</span>)</span><br><span class="line">model.<span class="keyword">add_transition(cloud_state, </span>rainy_state, <span class="number">0</span>.<span class="number">625</span>)</span><br><span class="line"><span class="comment"># 最后使用bake完结</span></span><br><span class="line">model.<span class="keyword">bake()</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">observations </span>= [<span class="string">'Dry'</span>, <span class="string">'Damp'</span>, <span class="string">'Soggy'</span>]</span><br><span class="line">forward_matrix = np.exp(model.forward(observations))</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use model.log_probability() to calculate the all-paths likelihood of the</span></span><br><span class="line"><span class="comment"># observed sequence and then use np.exp() to convert log-likelihood to likelihood</span></span><br><span class="line">probability_percentage = np.exp(model.log_probability(observations))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the forward probabilities</span></span><br><span class="line">print(<span class="string">"         "</span> + <span class="string">""</span>.<span class="keyword">join(s.name.center(len(s.name)+6) </span>for s in model.states))</span><br><span class="line">for i in range(len(observations) + <span class="number">1</span>):</span><br><span class="line">    print(<span class="string">" &lt;start&gt; "</span> if i==<span class="number">0</span> else observations[i - <span class="number">1</span>].center(<span class="number">9</span>), end=<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">""</span>.<span class="keyword">join("&#123;:.0f&#125;%".format(100 </span>* forward_matrix[i, <span class="keyword">j]).center(len(s.name) </span>+ <span class="number">6</span>)</span><br><span class="line">                  for <span class="keyword">j, </span>s in enumerate(model.states)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nThe likelihood over all possible paths "</span> + \</span><br><span class="line">      <span class="string">"of this model producing the sequence &#123;&#125; is &#123;:.2f&#125;%\n\n"</span></span><br><span class="line">      .format(observations, <span class="number">100</span> * probability_percentage))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;  

&lt;h3 id=&quot;隐马尔可夫模型在词性标注
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Basic modules of NLP python</title>
    <link href="http://yoursite.com/2018/11/18/python_models/"/>
    <id>http://yoursite.com/2018/11/18/python_models/</id>
    <published>2018-11-18T14:13:36.000Z</published>
    <updated>2018-11-18T14:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>指定二维数组, 可以调用a.keys()来查看索引  </li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = defaultdict(list)</span><br></pre></td></tr></table></figure><ol start="2"><li>Cunter 可以统计一个list中各个部件出现的数量，可以搭配上面的defaultlist使用  </li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;指定二维数组, 可以调用a.keys()来查看索引  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="tool" scheme="http://yoursite.com/categories/tool/"/>
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>spam classification --- naive bayes</title>
    <link href="http://yoursite.com/2018/11/16/spam-classification/"/>
    <id>http://yoursite.com/2018/11/16/spam-classification/</id>
    <published>2018-11-17T05:57:40.000Z</published>
    <updated>2018-11-17T05:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script> <h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><h5 id="我们在清分的时候认为有easy和money就可能使垃圾邮件，通过检查邮件中有两个单词就可以说明是否为spam，“朴素”贝叶斯朴素在于认为各个元素是相互独立的，因此直接将概率相乘"><a href="#我们在清分的时候认为有easy和money就可能使垃圾邮件，通过检查邮件中有两个单词就可以说明是否为spam，“朴素”贝叶斯朴素在于认为各个元素是相互独立的，因此直接将概率相乘" class="headerlink" title="我们在清分的时候认为有easy和money就可能使垃圾邮件，通过检查邮件中有两个单词就可以说明是否为spam，“朴素”贝叶斯朴素在于认为各个元素是相互独立的，因此直接将概率相乘"></a>我们在清分的时候认为有easy和money就可能使垃圾邮件，通过检查邮件中有两个单词就可以说明是否为spam，“朴素”贝叶斯朴素在于认为各个元素是相互独立的，因此直接将概率相乘</h5><p>$$<br>(1) P(spam) P(‘easy’|spam) P(‘money’|spam)  +  P(ham) P(‘easy’|ham) P(‘money’|ham) = \alpha<br>$$</p><p>$$<br>(2) P(spam|’easy’, ‘money’) = \frac{ P(spam) P(‘easy’|spam) P(‘money’|spam) }{\alpha}<br>$$    </p><p>$$<br>(3) P(ham|’easy’, ‘money’) = \frac{ P(ham) P(‘easy’|ham) P(‘money’|ham) }{\alpha}<br>$$</p><p>$$<br> Final : P(spam|’easy’, ‘money’)  +  P(ham|’easy’, ‘money’) = 1<br>$$</p><h5 id="当然我们在实际过程中调用sklearn-naive-bayes-MultinomialNB就可以"><a href="#当然我们在实际过程中调用sklearn-naive-bayes-MultinomialNB就可以" class="headerlink" title="当然我们在实际过程中调用sklearn.naive_bayes.MultinomialNB就可以"></a>当然我们在实际过程中调用sklearn.naive_bayes.MultinomialNB就可以</h5><h5 id="gt-注意训练数据的形式是dataframe，用pandas直接读取或者是用matrix转换"><a href="#gt-注意训练数据的形式是dataframe，用pandas直接读取或者是用matrix转换" class="headerlink" title="&gt; 注意训练数据的形式是dataframe，用pandas直接读取或者是用matrix转换"></a>&gt; 注意训练数据的形式是dataframe，用pandas直接读取或者是用matrix转换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Dataset from - https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line">df = pd.read_table(</span><br><span class="line">        <span class="string">'./smsspamcollection/SMSSpamCollection'</span>,</span><br><span class="line">        sep=<span class="string">'\t'</span>,</span><br><span class="line">       names = [<span class="string">'label'</span>, <span class="string">'sms_message'</span>]</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># Note1. 注意读出的是data_frame，命名用names</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">'label'</span>] = df.label.map(&#123;<span class="string">'spam'</span>:<span class="number">1</span>, <span class="string">'ham'</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note2. 二分类问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(df[<span class="string">'sms_message'</span>],</span><br><span class="line">                                                    df[<span class="string">'label'</span>],</span><br><span class="line">                                                    random_state=<span class="number">1</span>)</span><br><span class="line">count_vector = CountVectorizer()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">fit是找到规律，如果fit过之后就可以直接transform，因为规律已经学会了</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">training_data = count_vector.fit_transform(X_train)</span><br><span class="line">testing_data = count_vector.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line">naive_bayes = MultinomialNB()</span><br><span class="line">naive_bayes.fit(training_data, y_train)</span><br><span class="line">predictions = naive_bayes.predict(testing_data)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Precision tells us what proportion of messages we classified as spam, actually were spam.</span></span><br><span class="line"><span class="string">[True Positives/(True Positives + False Positives)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Recall tells us what proportion of messages we classified as spam in the total number of spam</span></span><br><span class="line"><span class="string">[True Positives/(True Positives + False Negatives)]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br><span class="line">print(<span class="string">'Accuracy score: '</span>, format(accuracy_score(y_test, predictions)))</span><br><span class="line">print(<span class="string">'Precision score: '</span>, format(precision_score(y_test, predictions)))</span><br><span class="line">print(<span class="string">'Recall score: '</span>, format(recall_score(y_test, predictions)))</span><br><span class="line">print(<span class="string">'F1 score: '</span>, format(f1_score(y_test, predictions)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt; 

&lt;h3 id=&quot;举个栗子&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>NLP(First) Text Processing</title>
    <link href="http://yoursite.com/2018/11/14/NLP1/"/>
    <id>http://yoursite.com/2018/11/14/NLP1/</id>
    <published>2018-11-14T14:26:22.000Z</published>
    <updated>2018-11-14T14:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="basic-rules-of-text-procession-and-how-to-use-nltk"><a href="#basic-rules-of-text-procession-and-how-to-use-nltk" class="headerlink" title="basic rules of text procession and how to use nltk"></a>basic rules of text procession and how to use nltk</h2><h3 id="下图是一个简单的处理流程"><a href="#下图是一个简单的处理流程" class="headerlink" title="下图是一个简单的处理流程"></a>下图是一个简单的处理流程</h3><p><img src="/images/NLP/text_processing/text_p.png" alt=""></p><p>判断一段文字中单词出现的数量是一个经典的问题，首先建立一个dict。接着把str用spilt给分开，用正则表达式去除标点，然后统计数量</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def count_words(str):</span><br><span class="line">    <span class="string">""</span><span class="string">"Count how many times each unique word occurs in text."</span><span class="string">""</span></span><br><span class="line">    counts = dict()  <span class="comment"># dictionary of &#123; &lt;word&gt;: &lt;count&gt; &#125; pairs to return</span></span><br><span class="line">    <span class="comment"># text = str(text)</span></span><br><span class="line">    <span class="comment"># str = "one and two and three and two and one\nbuffalo buffalo buffalo, buffalo buffalo!"</span></span><br><span class="line">    str = str.<span class="built_in">replace</span>(<span class="string">"\n"</span>, <span class="string">" "</span>)</span><br><span class="line">    str = str.<span class="built_in">lower</span>()</span><br><span class="line">    word_l = str.<span class="built_in">split</span>(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Split text into tokens (words), leaving out punctuation</span></span><br><span class="line">    <span class="comment"># (Hint: Use regex to split on non-alphanumeric characters)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Aggregate word counts using a dictionary</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> word_l:</span><br><span class="line">        <span class="built_in">word</span> = re.match(<span class="string">"([a-zA-Z]+).*"</span>, <span class="built_in">word</span>)</span><br><span class="line">        <span class="built_in">word</span> = <span class="built_in">word</span>.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">word</span> <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">            counts[<span class="built_in">word</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            counts[<span class="built_in">word</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="literal">return</span> counts</span><br></pre></td></tr></table></figure><p>看起来不错，但是如果有一套统一的工具来做这些是不是会更好，这时候就出现了nltk(Natural Language ToolKit)  </p><blockquote><p>pip install nltk  </p></blockquote><p><strong>1. from nltk.tokenize import word_tokenize</strong></p><blockquote><p>将一个句子中的单词一个个提取出来，相比于自己split好在他更智能。e.g. 可以提取出Dr.</p></blockquote><p><strong>2. from nltk.tokenize import sent_tokenize</strong> </p><blockquote><p>可以将一个个句子提取出来  </p></blockquote><p><strong>3. from nltk.corpus import stopwords</strong>  </p><blockquote><p>有一些句子中的单词是没有意义的，stopwords可以帮助我们快速提取出来  </p></blockquote><p><strong>4. Sentence Parsing</strong></p><blockquote><p>根据语法规则把一句话变成一棵树，没搞懂啥意思</p></blockquote><p><img src="/images/NLP/text_processing/parse_tree.png" alt=""></p><p><strong>5. Stemming &amp; Lemmatization</strong></p><blockquote><p>同一个单词可能有不同时态、单复数等，取其枝干可以大大减小运算量和内存占用  </p></blockquote><p>另外我们需要了解的还有beautiful的相应用法，imooc的爬虫课程讲解了基础。</p><p>正则表达式也是很重要的知识，在这里就不一一阐述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;basic-rules-of-text-procession-and-how-to-use-nltk&quot;&gt;&lt;a href=&quot;#basic-rules-of-text-procession-and-how-to-use-nltk&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
</feed>
